// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
